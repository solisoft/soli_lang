//! Lock file (soli.lock) for pinning resolved package versions.

use std::collections::HashMap;
use std::fs;
use std::path::{Path, PathBuf};

use super::package::Dependency;

/// A resolved lock file entry.
#[derive(Debug, Clone)]
pub struct LockEntry {
    /// Package name
    pub name: String,
    /// Git repository URL
    pub url: String,
    /// Full resolved commit SHA
    pub resolved_rev: String,
    /// Path to cached package on disk
    pub cache_path: PathBuf,
    /// Original tag or branch requested (for display)
    pub ref_spec: Option<String>,
}

/// The lock file containing all resolved package entries.
#[derive(Debug, Clone, Default)]
pub struct LockFile {
    /// Resolved packages keyed by name
    pub packages: HashMap<String, LockEntry>,
}

const LOCK_HEADER: &str = "# This file is auto-generated by soli. Do not edit manually.\n\
                            # It pins exact versions of dependencies for reproducible builds.\n";

impl LockFile {
    /// Load a lock file from disk.
    pub fn load(path: &Path) -> Result<Self, String> {
        if !path.exists() {
            return Ok(LockFile::default());
        }

        let content =
            fs::read_to_string(path).map_err(|e| format!("Failed to read lock file: {}", e))?;
        Self::parse(&content)
    }

    /// Parse lock file content.
    fn parse(content: &str) -> Result<Self, String> {
        let mut packages = HashMap::new();

        for line in content.lines() {
            let line = line.trim();
            // Skip comments and empty lines
            if line.is_empty() || line.starts_with('#') {
                continue;
            }

            let parts: Vec<&str> = line.splitn(5, '|').collect();
            if parts.len() < 4 {
                return Err(format!("Invalid lock file line: {}", line));
            }

            let name = parts[0].to_string();
            let url = parts[1].to_string();
            let resolved_rev = parts[2].to_string();
            let cache_path = PathBuf::from(parts[3]);
            let ref_spec = if parts.len() >= 5 && !parts[4].is_empty() {
                Some(parts[4].to_string())
            } else {
                None
            };

            packages.insert(
                name.clone(),
                LockEntry {
                    name,
                    url,
                    resolved_rev,
                    cache_path,
                    ref_spec,
                },
            );
        }

        Ok(LockFile { packages })
    }

    /// Save the lock file to disk.
    pub fn save(&self, path: &Path) -> Result<(), String> {
        let mut content = String::from(LOCK_HEADER);
        content.push('\n');

        // Sort entries for deterministic output
        let mut entries: Vec<_> = self.packages.values().collect();
        entries.sort_by(|a, b| a.name.cmp(&b.name));

        for entry in entries {
            content.push_str(&format!(
                "{}|{}|{}|{}|{}\n",
                entry.name,
                entry.url,
                entry.resolved_rev,
                entry.cache_path.display(),
                entry.ref_spec.as_deref().unwrap_or("")
            ));
        }

        fs::write(path, &content).map_err(|e| format!("Failed to write lock file: {}", e))
    }

    /// Check if a lock entry satisfies the given dependency.
    pub fn is_satisfied(&self, name: &str, dep: &Dependency) -> bool {
        let entry = match self.packages.get(name) {
            Some(e) => e,
            None => return false,
        };

        // Check that the cache directory exists
        if !entry.cache_path.exists() {
            return false;
        }

        match dep {
            Dependency::Git {
                url,
                tag,
                branch,
                rev,
                ..
            } => {
                // URL must match
                if entry.url != *url {
                    return false;
                }
                // If a specific rev is requested, it must match
                if let Some(r) = rev {
                    return entry.resolved_rev.starts_with(r);
                }
                // For tag/branch, the ref_spec should match what was requested
                if let Some(t) = tag {
                    return entry.ref_spec.as_deref() == Some(t.as_str());
                }
                if let Some(b) = branch {
                    return entry.ref_spec.as_deref() == Some(b.as_str());
                }
                // No specific ref requested, any resolved rev is fine
                true
            }
            Dependency::Version(ver) => entry.resolved_rev == *ver,
            _ => false,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_lock_file_roundtrip() {
        let mut lock = LockFile::default();
        lock.packages.insert(
            "math".to_string(),
            LockEntry {
                name: "math".to_string(),
                url: "https://github.com/user/soli-math".to_string(),
                resolved_rev: "abc123def456".to_string(),
                cache_path: PathBuf::from("/home/user/.soli/packages/math-abc123def456"),
                ref_spec: Some("v1.0.0".to_string()),
            },
        );

        let content = {
            let mut out = String::from(LOCK_HEADER);
            out.push('\n');
            for entry in lock.packages.values() {
                out.push_str(&format!(
                    "{}|{}|{}|{}|{}\n",
                    entry.name,
                    entry.url,
                    entry.resolved_rev,
                    entry.cache_path.display(),
                    entry.ref_spec.as_deref().unwrap_or("")
                ));
            }
            out
        };

        let parsed = LockFile::parse(&content).unwrap();
        assert_eq!(parsed.packages.len(), 1);

        let entry = &parsed.packages["math"];
        assert_eq!(entry.url, "https://github.com/user/soli-math");
        assert_eq!(entry.resolved_rev, "abc123def456");
        assert_eq!(entry.ref_spec.as_deref(), Some("v1.0.0"));
    }

    #[test]
    fn test_is_satisfied_matching() {
        let mut lock = LockFile::default();
        let cache_path = PathBuf::from("/tmp"); // exists on most systems
        lock.packages.insert(
            "math".to_string(),
            LockEntry {
                name: "math".to_string(),
                url: "https://github.com/user/soli-math".to_string(),
                resolved_rev: "abc123def456".to_string(),
                cache_path: cache_path.clone(),
                ref_spec: Some("v1.0.0".to_string()),
            },
        );

        let dep = Dependency::Git {
            url: "https://github.com/user/soli-math".to_string(),
            tag: Some("v1.0.0".to_string()),
            branch: None,
            rev: None,
        };

        assert!(lock.is_satisfied("math", &dep));
    }

    #[test]
    fn test_is_satisfied_wrong_url() {
        let mut lock = LockFile::default();
        lock.packages.insert(
            "math".to_string(),
            LockEntry {
                name: "math".to_string(),
                url: "https://github.com/user/soli-math".to_string(),
                resolved_rev: "abc123".to_string(),
                cache_path: PathBuf::from("/tmp"),
                ref_spec: Some("v1.0.0".to_string()),
            },
        );

        let dep = Dependency::Git {
            url: "https://github.com/other/soli-math".to_string(),
            tag: Some("v1.0.0".to_string()),
            branch: None,
            rev: None,
        };

        assert!(!lock.is_satisfied("math", &dep));
    }
}
