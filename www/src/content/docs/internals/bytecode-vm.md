---
title: Bytecode VM
description: Deep dive into Soli's bytecode virtual machine
---

# Bytecode Virtual Machine

The bytecode VM is a stack-based virtual machine that executes compiled bytecode instructions. It provides significant performance improvements over the tree-walk interpreter.

## Architecture Overview

```
┌─────────────┐     ┌──────────────┐     ┌─────────────┐
│   Source    │────▶│   Compiler   │────▶│  Bytecode   │
│    Code     │     │  (AST→BC)    │     │   Chunk     │
└─────────────┘     └──────────────┘     └─────────────┘
                                                │
                                                ▼
                                         ┌─────────────┐
                                         │     VM      │
                                         │  (Execute)  │
                                         └─────────────┘
```

## Components

### Chunk

A chunk contains compiled bytecode for a function:

- **Code**: Vector of bytecode instructions
- **Constants**: Literal values (numbers, strings, functions)
- **Line info**: Source line numbers for debugging

### OpCodes

The VM supports ~40 opcodes organized into categories:

#### Stack Operations
```
Constant    - Push a constant onto the stack
Null        - Push null
True/False  - Push boolean values
Pop         - Discard top of stack
Dup         - Duplicate top of stack
```

#### Arithmetic
```
Add         - Addition (also string concatenation)
Subtract    - Subtraction
Multiply    - Multiplication
Divide      - Division
Modulo      - Remainder
Negate      - Unary negation
```

#### Comparison
```
Equal       - Equality test
NotEqual    - Inequality test
Less        - Less than
LessEqual   - Less than or equal
Greater     - Greater than
GreaterEqual - Greater than or equal
```

#### Variables
```
GetLocal    - Read local variable
SetLocal    - Write local variable
GetGlobal   - Read global variable
SetGlobal   - Write global variable
DefineGlobal - Define new global
```

#### Control Flow
```
Jump        - Unconditional jump
JumpIfFalse - Jump if top of stack is falsy
JumpIfTrue  - Jump if top of stack is truthy
Loop        - Jump backwards (for loops)
```

#### Functions
```
Call        - Call a function
Return      - Return from function
Closure     - Create a closure
```

#### Objects
```
Class       - Define a class
GetProperty - Read object property
SetProperty - Write object property
Method      - Define a method
Invoke      - Optimized method call
New         - Create instance
```

## Execution Model

The VM uses a stack-based execution model with call frames:

```rust
struct VM {
    stack: Vec<VMValue>,      // Value stack
    frames: Vec<CallFrame>,   // Call stack
    globals: HashMap<...>,    // Global variables
}

struct CallFrame {
    closure: Closure,         // Function being executed
    ip: usize,               // Instruction pointer
    slots_start: usize,      // Start of local variables
}
```

### Example Execution

For the code:
```solilang
let x = 1 + 2;
```

Bytecode:
```
0000  Constant 0 (1)    ; Push 1
0003  Constant 1 (2)    ; Push 2
0006  Add               ; Pop both, push 3
0007  DefineGlobal 2 (x); Define x = 3
```

Stack trace:
```
Initial:    []
After 0000: [1]
After 0003: [1, 2]
After 0006: [3]
After 0007: []  (x is now defined)
```

## Closures and Upvalues

Closures capture variables from enclosing scopes:

```solilang
fn makeCounter() -> Fn() -> Int {
    let count = 0;
    return fn() -> Int {
        count = count + 1;  // Captures 'count'
        return count;
    };
}
```

The VM uses **upvalues** to track captured variables:
- **Open upvalue**: Points to stack slot
- **Closed upvalue**: Holds the value directly

When a variable goes out of scope, open upvalues are "closed" to preserve the value.

## Performance Optimizations

1. **Indexed locals**: Variables accessed by slot index, not name lookup
2. **Inline caching**: Method dispatch optimization (planned)
3. **NaN boxing**: Compact value representation (planned)
4. **Computed goto**: Fast opcode dispatch (platform-dependent)

## Debugging

Use `--disassemble` to see generated bytecode:

```bash
soli --disassemble your_script.soli
```

This shows:
- Offset and line numbers
- Opcode names
- Operands with resolved values

Example:
```
== fib (arity: 1) ==
0000    2 GetLocal 0 (?0)
0003    | Constant 0 (1)
0006    | LessEqual
0007    | JumpIfFalse 5 -> 15
...
```
